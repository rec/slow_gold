// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rec/slow/commands/Command.proto

#ifndef PROTOBUF_rec_2fslow_2fcommands_2fCommand_2eproto__INCLUDED
#define PROTOBUF_rec_2fslow_2fcommands_2fCommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "rec/command/Command.pb.h"
#include "rec/command/map/CommandMap.pb.h"
// @@protoc_insertion_point(includes)

namespace rec {
namespace slow {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

class Command;
class Commands;
class CommandMapEntry;
class CommandMapProto;
class MenuEntry;
class Menu;
class Menus;

enum Command_Id {
  Command_Id_NONE = 0,
  Command_Id_ABOUT_THIS_PROGRAM = 58,
  Command_Id_ADD_LOOP_POINT = 1,
  Command_Id_AUDIO_PREFERENCES = 2,
  Command_Id_CHECK_FOR_UPDATES = 68,
  Command_Id_CLEAR_KEYBOARD_MAPPINGS = 91,
  Command_Id_CLEAR_MIDI_MAPPINGS = 92,
  Command_Id_CLEAR_LOOPS = 4,
  Command_Id_CLEAR_NAVIGATOR = 3,
  Command_Id_CLEAR_ALL_SETTINGS = 79,
  Command_Id_CLEAR_SETTINGS_FOR_THIS_TRACK = 80,
  Command_Id_CLEAR_SAVED_FILE_DATA = 5,
  Command_Id_CLOSE_FILE = 6,
  Command_Id_COPY_ALL_LOOP_POINTS = 95,
  Command_Id_DIM_VOLUME_TOGGLE = 7,
  Command_Id_EJECT_CDS = 8,
  Command_Id_EXPORT_KEYBOARD_MAPPINGS = 82,
  Command_Id_EXPORT_MIDI_MAPPINGS = 83,
  Command_Id_EXPORT_SETTINGS = 75,
  Command_Id_IMPORT_KEYBOARD_MAPPINGS = 84,
  Command_Id_IMPORT_MIDI_MAPPINGS = 85,
  Command_Id_IMPORT_SETTINGS = 76,
  Command_Id_INVERT_LOOP_SELECTION = 9,
  Command_Id_JUMP = 100000,
  Command_Id_JUMP_SELECTED = 110000,
  Command_Id_KEYBOARD_MAPPINGS = 12,
  Command_Id_LOOP_NEXT_SEGMENT = 94,
  Command_Id_MIDI_MAPPINGS = 13,
  Command_Id_MODE_ADD_LOOP_POINT = 63,
  Command_Id_MODE_DRAG = 60,
  Command_Id_MODE_SET_TIME = 61,
  Command_Id_MODE_ZOOM_IN = 62,
  Command_Id_MUTE_VOLUME_TOGGLE = 14,
  Command_Id_NUDGE_BACKWARD = 89,
  Command_Id_NUDGE_FORWARD = 90,
  Command_Id_NUDGE_BEGIN_LEFT = 15,
  Command_Id_NUDGE_BEGIN_RIGHT = 16,
  Command_Id_NUDGE_END_LEFT = 17,
  Command_Id_NUDGE_END_RIGHT = 18,
  Command_Id_NUDGE_SPEED_DOWN = 86,
  Command_Id_NUDGE_SPEED_UP = 87,
  Command_Id_NUDGE_VOLUME_DOWN = 19,
  Command_Id_NUDGE_VOLUME_UP = 20,
  Command_Id_OPEN = 21,
  Command_Id_OPEN_MANUAL = 65,
  Command_Id_OPEN_PREVIOUS_FILE = 78,
  Command_Id_OPEN_SLOWGOLD_DIRECTORY = 74,
  Command_Id_PASTE_OVER_LOOP_POINTS = 96,
  Command_Id_RECENT_FILES = 220000,
  Command_Id_REDO = 23,
  Command_Id_REQUEST_SUPPORT = 66,
  Command_Id_RESET_GAIN_TO_UNITY = 24,
  Command_Id_SAVE_FILE = 69,
  Command_Id_SAVE_FILE_SELECTION = 70,
  Command_Id_SELECT = 250000,
  Command_Id_SELECT_ONLY = 260000,
  Command_Id_SET_LANGUAGE = 930000,
  Command_Id_SET_SAVE_FORMAT = 710000,
  Command_Id_SET_SAVE_AS_AIFF = 97,
  Command_Id_SET_SAVE_AS_FLAC = 98,
  Command_Id_SET_SAVE_AS_OGG = 99,
  Command_Id_SET_SAVE_AS_WAV = 100,
  Command_Id_TOGGLE_ADVANCED_MENUS = 59,
  Command_Id_TOGGLE_AUTOMATIC_UPDATES = 67,
  Command_Id_TOGGLE_FOLLOW_CURSOR = 43,
  Command_Id_TOGGLE_GRID_DISPLAY = 27,
  Command_Id_TOGGLE_COMMAND_BAR_AT_LEFT = 54,
  Command_Id_TOGGLE_COMMAND_BAR_AT_TOP = 55,
  Command_Id_TOGGLE_FILE_OPEN_TREE_DISPLAY = 72,
  Command_Id_TOGGLE_MODES_AT_LEFT = 56,
  Command_Id_TOGGLE_MODES_AT_TOP = 57,
  Command_Id_TOGGLE_PARALLEL_WAVEFORMS = 42,
  Command_Id_TOGGLE_PREFADER_LEVELS = 46,
  Command_Id_TOGGLE_SELECTION = 410000,
  Command_Id_TOGGLE_SHOW_ABOUT_WINDOW_AT_STARTUP = 81,
  Command_Id_TOGGLE_SHOW_CURSOR_LABELS = 51,
  Command_Id_TOGGLE_SHOW_HELP_PANE = 49,
  Command_Id_TOGGLE_SHOW_LABELS_AT_TOP = 52,
  Command_Id_TOGGLE_SHOW_MASTER_TUNE = 77,
  Command_Id_TOGGLE_SHOW_SELECTION_BUTTONS = 50,
  Command_Id_TOGGLE_SHOW_TIMES_AT_TOP = 53,
  Command_Id_TOGGLE_SHOW_TOOLTIPS = 48,
  Command_Id_TOGGLE_START_STOP = 28,
  Command_Id_TOGGLE_STRETCH_ENABLE = 29,
  Command_Id_TOGGLE_TRANSFORM_ENABLE = 88,
  Command_Id_TOGGLE_WHOLE_SONG_LOOP = 30,
  Command_Id_TREE_CLOSE = 31,
  Command_Id_TREE_DOWN = 32,
  Command_Id_TREE_LEFT = 33,
  Command_Id_TREE_OPEN = 34,
  Command_Id_TREE_RIGHT = 35,
  Command_Id_TREE_UP = 36,
  Command_Id_UNDO = 37,
  Command_Id_UNSELECT = 380000,
  Command_Id_WHATS_NEW_PAGE = 73,
  Command_Id_ZOOM_IN = 39,
  Command_Id_ZOOM_OUT = 40,
  Command_Id_ZOOM_OUT_FULL = 64,
  Command_Id_ZOOM_TO_SELECTION = 45,
  Command_Id_FIRST_FREE_TYPE = 101,
  Command_Id_QUIT = 4097,
  Command_Id_DEL = 4098,
  Command_Id_CUT = 4099,
  Command_Id_COPY = 4100,
  Command_Id_PASTE = 4101,
  Command_Id_SELECT_ALL = 4102,
  Command_Id_DESELECT_ALL = 4103
};
bool Command_Id_IsValid(int value);
const Command_Id Command_Id_Id_MIN = Command_Id_NONE;
const Command_Id Command_Id_Id_MAX = Command_Id_SET_LANGUAGE;
const int Command_Id_Id_ARRAYSIZE = Command_Id_Id_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Id_descriptor();
inline const ::std::string& Command_Id_Name(Command_Id value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Id_descriptor(), value);
}
inline bool Command_Id_Parse(
    const ::std::string& name, Command_Id* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Id>(
    Command_Id_descriptor(), name, value);
}
// ===================================================================

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Id Id;
  static const Id NONE = Command_Id_NONE;
  static const Id ABOUT_THIS_PROGRAM = Command_Id_ABOUT_THIS_PROGRAM;
  static const Id ADD_LOOP_POINT = Command_Id_ADD_LOOP_POINT;
  static const Id AUDIO_PREFERENCES = Command_Id_AUDIO_PREFERENCES;
  static const Id CHECK_FOR_UPDATES = Command_Id_CHECK_FOR_UPDATES;
  static const Id CLEAR_KEYBOARD_MAPPINGS = Command_Id_CLEAR_KEYBOARD_MAPPINGS;
  static const Id CLEAR_MIDI_MAPPINGS = Command_Id_CLEAR_MIDI_MAPPINGS;
  static const Id CLEAR_LOOPS = Command_Id_CLEAR_LOOPS;
  static const Id CLEAR_NAVIGATOR = Command_Id_CLEAR_NAVIGATOR;
  static const Id CLEAR_ALL_SETTINGS = Command_Id_CLEAR_ALL_SETTINGS;
  static const Id CLEAR_SETTINGS_FOR_THIS_TRACK = Command_Id_CLEAR_SETTINGS_FOR_THIS_TRACK;
  static const Id CLEAR_SAVED_FILE_DATA = Command_Id_CLEAR_SAVED_FILE_DATA;
  static const Id CLOSE_FILE = Command_Id_CLOSE_FILE;
  static const Id COPY_ALL_LOOP_POINTS = Command_Id_COPY_ALL_LOOP_POINTS;
  static const Id DIM_VOLUME_TOGGLE = Command_Id_DIM_VOLUME_TOGGLE;
  static const Id EJECT_CDS = Command_Id_EJECT_CDS;
  static const Id EXPORT_KEYBOARD_MAPPINGS = Command_Id_EXPORT_KEYBOARD_MAPPINGS;
  static const Id EXPORT_MIDI_MAPPINGS = Command_Id_EXPORT_MIDI_MAPPINGS;
  static const Id EXPORT_SETTINGS = Command_Id_EXPORT_SETTINGS;
  static const Id IMPORT_KEYBOARD_MAPPINGS = Command_Id_IMPORT_KEYBOARD_MAPPINGS;
  static const Id IMPORT_MIDI_MAPPINGS = Command_Id_IMPORT_MIDI_MAPPINGS;
  static const Id IMPORT_SETTINGS = Command_Id_IMPORT_SETTINGS;
  static const Id INVERT_LOOP_SELECTION = Command_Id_INVERT_LOOP_SELECTION;
  static const Id JUMP = Command_Id_JUMP;
  static const Id JUMP_SELECTED = Command_Id_JUMP_SELECTED;
  static const Id KEYBOARD_MAPPINGS = Command_Id_KEYBOARD_MAPPINGS;
  static const Id LOOP_NEXT_SEGMENT = Command_Id_LOOP_NEXT_SEGMENT;
  static const Id MIDI_MAPPINGS = Command_Id_MIDI_MAPPINGS;
  static const Id MODE_ADD_LOOP_POINT = Command_Id_MODE_ADD_LOOP_POINT;
  static const Id MODE_DRAG = Command_Id_MODE_DRAG;
  static const Id MODE_SET_TIME = Command_Id_MODE_SET_TIME;
  static const Id MODE_ZOOM_IN = Command_Id_MODE_ZOOM_IN;
  static const Id MUTE_VOLUME_TOGGLE = Command_Id_MUTE_VOLUME_TOGGLE;
  static const Id NUDGE_BACKWARD = Command_Id_NUDGE_BACKWARD;
  static const Id NUDGE_FORWARD = Command_Id_NUDGE_FORWARD;
  static const Id NUDGE_BEGIN_LEFT = Command_Id_NUDGE_BEGIN_LEFT;
  static const Id NUDGE_BEGIN_RIGHT = Command_Id_NUDGE_BEGIN_RIGHT;
  static const Id NUDGE_END_LEFT = Command_Id_NUDGE_END_LEFT;
  static const Id NUDGE_END_RIGHT = Command_Id_NUDGE_END_RIGHT;
  static const Id NUDGE_SPEED_DOWN = Command_Id_NUDGE_SPEED_DOWN;
  static const Id NUDGE_SPEED_UP = Command_Id_NUDGE_SPEED_UP;
  static const Id NUDGE_VOLUME_DOWN = Command_Id_NUDGE_VOLUME_DOWN;
  static const Id NUDGE_VOLUME_UP = Command_Id_NUDGE_VOLUME_UP;
  static const Id OPEN = Command_Id_OPEN;
  static const Id OPEN_MANUAL = Command_Id_OPEN_MANUAL;
  static const Id OPEN_PREVIOUS_FILE = Command_Id_OPEN_PREVIOUS_FILE;
  static const Id OPEN_SLOWGOLD_DIRECTORY = Command_Id_OPEN_SLOWGOLD_DIRECTORY;
  static const Id PASTE_OVER_LOOP_POINTS = Command_Id_PASTE_OVER_LOOP_POINTS;
  static const Id RECENT_FILES = Command_Id_RECENT_FILES;
  static const Id REDO = Command_Id_REDO;
  static const Id REQUEST_SUPPORT = Command_Id_REQUEST_SUPPORT;
  static const Id RESET_GAIN_TO_UNITY = Command_Id_RESET_GAIN_TO_UNITY;
  static const Id SAVE_FILE = Command_Id_SAVE_FILE;
  static const Id SAVE_FILE_SELECTION = Command_Id_SAVE_FILE_SELECTION;
  static const Id SELECT = Command_Id_SELECT;
  static const Id SELECT_ONLY = Command_Id_SELECT_ONLY;
  static const Id SET_LANGUAGE = Command_Id_SET_LANGUAGE;
  static const Id SET_SAVE_FORMAT = Command_Id_SET_SAVE_FORMAT;
  static const Id SET_SAVE_AS_AIFF = Command_Id_SET_SAVE_AS_AIFF;
  static const Id SET_SAVE_AS_FLAC = Command_Id_SET_SAVE_AS_FLAC;
  static const Id SET_SAVE_AS_OGG = Command_Id_SET_SAVE_AS_OGG;
  static const Id SET_SAVE_AS_WAV = Command_Id_SET_SAVE_AS_WAV;
  static const Id TOGGLE_ADVANCED_MENUS = Command_Id_TOGGLE_ADVANCED_MENUS;
  static const Id TOGGLE_AUTOMATIC_UPDATES = Command_Id_TOGGLE_AUTOMATIC_UPDATES;
  static const Id TOGGLE_FOLLOW_CURSOR = Command_Id_TOGGLE_FOLLOW_CURSOR;
  static const Id TOGGLE_GRID_DISPLAY = Command_Id_TOGGLE_GRID_DISPLAY;
  static const Id TOGGLE_COMMAND_BAR_AT_LEFT = Command_Id_TOGGLE_COMMAND_BAR_AT_LEFT;
  static const Id TOGGLE_COMMAND_BAR_AT_TOP = Command_Id_TOGGLE_COMMAND_BAR_AT_TOP;
  static const Id TOGGLE_FILE_OPEN_TREE_DISPLAY = Command_Id_TOGGLE_FILE_OPEN_TREE_DISPLAY;
  static const Id TOGGLE_MODES_AT_LEFT = Command_Id_TOGGLE_MODES_AT_LEFT;
  static const Id TOGGLE_MODES_AT_TOP = Command_Id_TOGGLE_MODES_AT_TOP;
  static const Id TOGGLE_PARALLEL_WAVEFORMS = Command_Id_TOGGLE_PARALLEL_WAVEFORMS;
  static const Id TOGGLE_PREFADER_LEVELS = Command_Id_TOGGLE_PREFADER_LEVELS;
  static const Id TOGGLE_SELECTION = Command_Id_TOGGLE_SELECTION;
  static const Id TOGGLE_SHOW_ABOUT_WINDOW_AT_STARTUP = Command_Id_TOGGLE_SHOW_ABOUT_WINDOW_AT_STARTUP;
  static const Id TOGGLE_SHOW_CURSOR_LABELS = Command_Id_TOGGLE_SHOW_CURSOR_LABELS;
  static const Id TOGGLE_SHOW_HELP_PANE = Command_Id_TOGGLE_SHOW_HELP_PANE;
  static const Id TOGGLE_SHOW_LABELS_AT_TOP = Command_Id_TOGGLE_SHOW_LABELS_AT_TOP;
  static const Id TOGGLE_SHOW_MASTER_TUNE = Command_Id_TOGGLE_SHOW_MASTER_TUNE;
  static const Id TOGGLE_SHOW_SELECTION_BUTTONS = Command_Id_TOGGLE_SHOW_SELECTION_BUTTONS;
  static const Id TOGGLE_SHOW_TIMES_AT_TOP = Command_Id_TOGGLE_SHOW_TIMES_AT_TOP;
  static const Id TOGGLE_SHOW_TOOLTIPS = Command_Id_TOGGLE_SHOW_TOOLTIPS;
  static const Id TOGGLE_START_STOP = Command_Id_TOGGLE_START_STOP;
  static const Id TOGGLE_STRETCH_ENABLE = Command_Id_TOGGLE_STRETCH_ENABLE;
  static const Id TOGGLE_TRANSFORM_ENABLE = Command_Id_TOGGLE_TRANSFORM_ENABLE;
  static const Id TOGGLE_WHOLE_SONG_LOOP = Command_Id_TOGGLE_WHOLE_SONG_LOOP;
  static const Id TREE_CLOSE = Command_Id_TREE_CLOSE;
  static const Id TREE_DOWN = Command_Id_TREE_DOWN;
  static const Id TREE_LEFT = Command_Id_TREE_LEFT;
  static const Id TREE_OPEN = Command_Id_TREE_OPEN;
  static const Id TREE_RIGHT = Command_Id_TREE_RIGHT;
  static const Id TREE_UP = Command_Id_TREE_UP;
  static const Id UNDO = Command_Id_UNDO;
  static const Id UNSELECT = Command_Id_UNSELECT;
  static const Id WHATS_NEW_PAGE = Command_Id_WHATS_NEW_PAGE;
  static const Id ZOOM_IN = Command_Id_ZOOM_IN;
  static const Id ZOOM_OUT = Command_Id_ZOOM_OUT;
  static const Id ZOOM_OUT_FULL = Command_Id_ZOOM_OUT_FULL;
  static const Id ZOOM_TO_SELECTION = Command_Id_ZOOM_TO_SELECTION;
  static const Id FIRST_FREE_TYPE = Command_Id_FIRST_FREE_TYPE;
  static const Id QUIT = Command_Id_QUIT;
  static const Id DEL = Command_Id_DEL;
  static const Id CUT = Command_Id_CUT;
  static const Id COPY = Command_Id_COPY;
  static const Id PASTE = Command_Id_PASTE;
  static const Id SELECT_ALL = Command_Id_SELECT_ALL;
  static const Id DESELECT_ALL = Command_Id_DESELECT_ALL;
  static inline bool Id_IsValid(int value) {
    return Command_Id_IsValid(value);
  }
  static const Id Id_MIN =
    Command_Id_Id_MIN;
  static const Id Id_MAX =
    Command_Id_Id_MAX;
  static const int Id_ARRAYSIZE =
    Command_Id_Id_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Id_descriptor() {
    return Command_Id_descriptor();
  }
  static inline const ::std::string& Id_Name(Id value) {
    return Command_Id_Name(value);
  }
  static inline bool Id_Parse(const ::std::string& name,
      Id* value) {
    return Command_Id_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .rec.slow.Command.Id id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::rec::slow::Command_Id id() const;
  inline void set_id(::rec::slow::Command_Id value);

  // optional .rec.command.Command command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::rec::command::Command& command() const;
  inline ::rec::command::Command* mutable_command();
  inline ::rec::command::Command* release_command();
  inline void set_allocated_command(::rec::command::Command* command);

  // @@protoc_insertion_point(class_scope:rec.slow.Command)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_command();
  inline void clear_has_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rec::command::Command* command_;
  int id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Commands : public ::google::protobuf::Message {
 public:
  Commands();
  virtual ~Commands();

  Commands(const Commands& from);

  inline Commands& operator=(const Commands& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Commands& default_instance();

  void Swap(Commands* other);

  // implements Message ----------------------------------------------

  Commands* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Commands& from);
  void MergeFrom(const Commands& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rec.slow.Command command = 1;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::rec::slow::Command& command(int index) const;
  inline ::rec::slow::Command* mutable_command(int index);
  inline ::rec::slow::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::rec::slow::Command >*
      mutable_command();

  // @@protoc_insertion_point(class_scope:rec.slow.Commands)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::rec::slow::Command > command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Commands* default_instance_;
};
// -------------------------------------------------------------------

class CommandMapEntry : public ::google::protobuf::Message {
 public:
  CommandMapEntry();
  virtual ~CommandMapEntry();

  CommandMapEntry(const CommandMapEntry& from);

  inline CommandMapEntry& operator=(const CommandMapEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMapEntry& default_instance();

  void Swap(CommandMapEntry* other);

  // implements Message ----------------------------------------------

  CommandMapEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMapEntry& from);
  void MergeFrom(const CommandMapEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rec.slow.Command.Id id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::rec::slow::Command_Id id() const;
  inline void set_id(::rec::slow::Command_Id value);

  // optional .rec.command.CommandMapEntry entry = 2;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline const ::rec::command::CommandMapEntry& entry() const;
  inline ::rec::command::CommandMapEntry* mutable_entry();
  inline ::rec::command::CommandMapEntry* release_entry();
  inline void set_allocated_entry(::rec::command::CommandMapEntry* entry);

  // @@protoc_insertion_point(class_scope:rec.slow.CommandMapEntry)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_entry();
  inline void clear_has_entry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rec::command::CommandMapEntry* entry_;
  int id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static CommandMapEntry* default_instance_;
};
// -------------------------------------------------------------------

class CommandMapProto : public ::google::protobuf::Message {
 public:
  CommandMapProto();
  virtual ~CommandMapProto();

  CommandMapProto(const CommandMapProto& from);

  inline CommandMapProto& operator=(const CommandMapProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandMapProto& default_instance();

  void Swap(CommandMapProto* other);

  // implements Message ----------------------------------------------

  CommandMapProto* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandMapProto& from);
  void MergeFrom(const CommandMapProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rec.slow.CommandMapEntry entry = 1;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 1;
  inline const ::rec::slow::CommandMapEntry& entry(int index) const;
  inline ::rec::slow::CommandMapEntry* mutable_entry(int index);
  inline ::rec::slow::CommandMapEntry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::CommandMapEntry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::rec::slow::CommandMapEntry >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:rec.slow.CommandMapProto)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::rec::slow::CommandMapEntry > entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static CommandMapProto* default_instance_;
};
// -------------------------------------------------------------------

class MenuEntry : public ::google::protobuf::Message {
 public:
  MenuEntry();
  virtual ~MenuEntry();

  MenuEntry(const MenuEntry& from);

  inline MenuEntry& operator=(const MenuEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MenuEntry& default_instance();

  void Swap(MenuEntry* other);

  // implements Message ----------------------------------------------

  MenuEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MenuEntry& from);
  void MergeFrom(const MenuEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rec.slow.Command.Id id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::rec::slow::Command_Id id(int index) const;
  inline void set_id(int index, ::rec::slow::Command_Id value);
  inline void add_id(::rec::slow::Command_Id value);
  inline const ::google::protobuf::RepeatedField<int>& id() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_id();

  // optional string submenu = 2;
  inline bool has_submenu() const;
  inline void clear_submenu();
  static const int kSubmenuFieldNumber = 2;
  inline const ::std::string& submenu() const;
  inline void set_submenu(const ::std::string& value);
  inline void set_submenu(const char* value);
  inline void set_submenu(const char* value, size_t size);
  inline ::std::string* mutable_submenu();
  inline ::std::string* release_submenu();
  inline void set_allocated_submenu(::std::string* submenu);

  // optional string callout_function = 3;
  inline bool has_callout_function() const;
  inline void clear_callout_function();
  static const int kCalloutFunctionFieldNumber = 3;
  inline const ::std::string& callout_function() const;
  inline void set_callout_function(const ::std::string& value);
  inline void set_callout_function(const char* value);
  inline void set_callout_function(const char* value, size_t size);
  inline ::std::string* mutable_callout_function();
  inline ::std::string* release_callout_function();
  inline void set_allocated_callout_function(::std::string* callout_function);

  // @@protoc_insertion_point(class_scope:rec.slow.MenuEntry)
 private:
  inline void set_has_submenu();
  inline void clear_has_submenu();
  inline void set_has_callout_function();
  inline void clear_has_callout_function();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> id_;
  ::std::string* submenu_;
  ::std::string* callout_function_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static MenuEntry* default_instance_;
};
// -------------------------------------------------------------------

class Menu : public ::google::protobuf::Message {
 public:
  Menu();
  virtual ~Menu();

  Menu(const Menu& from);

  inline Menu& operator=(const Menu& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Menu& default_instance();

  void Swap(Menu* other);

  // implements Message ----------------------------------------------

  Menu* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Menu& from);
  void MergeFrom(const Menu& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rec.command.Description description = 1;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 1;
  inline const ::rec::command::Description& description() const;
  inline ::rec::command::Description* mutable_description();
  inline ::rec::command::Description* release_description();
  inline void set_allocated_description(::rec::command::Description* description);

  // optional string extends = 2;
  inline bool has_extends() const;
  inline void clear_extends();
  static const int kExtendsFieldNumber = 2;
  inline const ::std::string& extends() const;
  inline void set_extends(const ::std::string& value);
  inline void set_extends(const char* value);
  inline void set_extends(const char* value, size_t size);
  inline ::std::string* mutable_extends();
  inline ::std::string* release_extends();
  inline void set_allocated_extends(::std::string* extends);

  // repeated .rec.slow.MenuEntry entry = 3;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 3;
  inline const ::rec::slow::MenuEntry& entry(int index) const;
  inline ::rec::slow::MenuEntry* mutable_entry(int index);
  inline ::rec::slow::MenuEntry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::MenuEntry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::rec::slow::MenuEntry >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:rec.slow.Menu)
 private:
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_extends();
  inline void clear_has_extends();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::rec::command::Description* description_;
  ::std::string* extends_;
  ::google::protobuf::RepeatedPtrField< ::rec::slow::MenuEntry > entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Menu* default_instance_;
};
// -------------------------------------------------------------------

class Menus : public ::google::protobuf::Message {
 public:
  Menus();
  virtual ~Menus();

  Menus(const Menus& from);

  inline Menus& operator=(const Menus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Menus& default_instance();

  void Swap(Menus* other);

  // implements Message ----------------------------------------------

  Menus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Menus& from);
  void MergeFrom(const Menus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rec.slow.Menu menu = 1;
  inline int menu_size() const;
  inline void clear_menu();
  static const int kMenuFieldNumber = 1;
  inline const ::rec::slow::Menu& menu(int index) const;
  inline ::rec::slow::Menu* mutable_menu(int index);
  inline ::rec::slow::Menu* add_menu();
  inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::Menu >&
      menu() const;
  inline ::google::protobuf::RepeatedPtrField< ::rec::slow::Menu >*
      mutable_menu();

  // @@protoc_insertion_point(class_scope:rec.slow.Menus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::rec::slow::Menu > menu_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fslow_2fcommands_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fslow_2fcommands_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Menus* default_instance_;
};
// ===================================================================


// ===================================================================

// Command

// optional .rec.slow.Command.Id id = 1;
inline bool Command::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::rec::slow::Command_Id Command::id() const {
  return static_cast< ::rec::slow::Command_Id >(id_);
}
inline void Command::set_id(::rec::slow::Command_Id value) {
  assert(::rec::slow::Command_Id_IsValid(value));
  set_has_id();
  id_ = value;
}

// optional .rec.command.Command command = 2;
inline bool Command::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_command() {
  if (command_ != NULL) command_->::rec::command::Command::Clear();
  clear_has_command();
}
inline const ::rec::command::Command& Command::command() const {
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::rec::command::Command* Command::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::rec::command::Command;
  return command_;
}
inline ::rec::command::Command* Command::release_command() {
  clear_has_command();
  ::rec::command::Command* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Command::set_allocated_command(::rec::command::Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
}

// -------------------------------------------------------------------

// Commands

// repeated .rec.slow.Command command = 1;
inline int Commands::command_size() const {
  return command_.size();
}
inline void Commands::clear_command() {
  command_.Clear();
}
inline const ::rec::slow::Command& Commands::command(int index) const {
  return command_.Get(index);
}
inline ::rec::slow::Command* Commands::mutable_command(int index) {
  return command_.Mutable(index);
}
inline ::rec::slow::Command* Commands::add_command() {
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::Command >&
Commands::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::rec::slow::Command >*
Commands::mutable_command() {
  return &command_;
}

// -------------------------------------------------------------------

// CommandMapEntry

// optional .rec.slow.Command.Id id = 1;
inline bool CommandMapEntry::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommandMapEntry::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommandMapEntry::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommandMapEntry::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::rec::slow::Command_Id CommandMapEntry::id() const {
  return static_cast< ::rec::slow::Command_Id >(id_);
}
inline void CommandMapEntry::set_id(::rec::slow::Command_Id value) {
  assert(::rec::slow::Command_Id_IsValid(value));
  set_has_id();
  id_ = value;
}

// optional .rec.command.CommandMapEntry entry = 2;
inline bool CommandMapEntry::has_entry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommandMapEntry::set_has_entry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommandMapEntry::clear_has_entry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommandMapEntry::clear_entry() {
  if (entry_ != NULL) entry_->::rec::command::CommandMapEntry::Clear();
  clear_has_entry();
}
inline const ::rec::command::CommandMapEntry& CommandMapEntry::entry() const {
  return entry_ != NULL ? *entry_ : *default_instance_->entry_;
}
inline ::rec::command::CommandMapEntry* CommandMapEntry::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) entry_ = new ::rec::command::CommandMapEntry;
  return entry_;
}
inline ::rec::command::CommandMapEntry* CommandMapEntry::release_entry() {
  clear_has_entry();
  ::rec::command::CommandMapEntry* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline void CommandMapEntry::set_allocated_entry(::rec::command::CommandMapEntry* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
}

// -------------------------------------------------------------------

// CommandMapProto

// repeated .rec.slow.CommandMapEntry entry = 1;
inline int CommandMapProto::entry_size() const {
  return entry_.size();
}
inline void CommandMapProto::clear_entry() {
  entry_.Clear();
}
inline const ::rec::slow::CommandMapEntry& CommandMapProto::entry(int index) const {
  return entry_.Get(index);
}
inline ::rec::slow::CommandMapEntry* CommandMapProto::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::rec::slow::CommandMapEntry* CommandMapProto::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::CommandMapEntry >&
CommandMapProto::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::rec::slow::CommandMapEntry >*
CommandMapProto::mutable_entry() {
  return &entry_;
}

// -------------------------------------------------------------------

// MenuEntry

// repeated .rec.slow.Command.Id id = 1;
inline int MenuEntry::id_size() const {
  return id_.size();
}
inline void MenuEntry::clear_id() {
  id_.Clear();
}
inline ::rec::slow::Command_Id MenuEntry::id(int index) const {
  return static_cast< ::rec::slow::Command_Id >(id_.Get(index));
}
inline void MenuEntry::set_id(int index, ::rec::slow::Command_Id value) {
  assert(::rec::slow::Command_Id_IsValid(value));
  id_.Set(index, value);
}
inline void MenuEntry::add_id(::rec::slow::Command_Id value) {
  assert(::rec::slow::Command_Id_IsValid(value));
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
MenuEntry::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField<int>*
MenuEntry::mutable_id() {
  return &id_;
}

// optional string submenu = 2;
inline bool MenuEntry::has_submenu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MenuEntry::set_has_submenu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MenuEntry::clear_has_submenu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MenuEntry::clear_submenu() {
  if (submenu_ != &::google::protobuf::internal::kEmptyString) {
    submenu_->clear();
  }
  clear_has_submenu();
}
inline const ::std::string& MenuEntry::submenu() const {
  return *submenu_;
}
inline void MenuEntry::set_submenu(const ::std::string& value) {
  set_has_submenu();
  if (submenu_ == &::google::protobuf::internal::kEmptyString) {
    submenu_ = new ::std::string;
  }
  submenu_->assign(value);
}
inline void MenuEntry::set_submenu(const char* value) {
  set_has_submenu();
  if (submenu_ == &::google::protobuf::internal::kEmptyString) {
    submenu_ = new ::std::string;
  }
  submenu_->assign(value);
}
inline void MenuEntry::set_submenu(const char* value, size_t size) {
  set_has_submenu();
  if (submenu_ == &::google::protobuf::internal::kEmptyString) {
    submenu_ = new ::std::string;
  }
  submenu_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MenuEntry::mutable_submenu() {
  set_has_submenu();
  if (submenu_ == &::google::protobuf::internal::kEmptyString) {
    submenu_ = new ::std::string;
  }
  return submenu_;
}
inline ::std::string* MenuEntry::release_submenu() {
  clear_has_submenu();
  if (submenu_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = submenu_;
    submenu_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MenuEntry::set_allocated_submenu(::std::string* submenu) {
  if (submenu_ != &::google::protobuf::internal::kEmptyString) {
    delete submenu_;
  }
  if (submenu) {
    set_has_submenu();
    submenu_ = submenu;
  } else {
    clear_has_submenu();
    submenu_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string callout_function = 3;
inline bool MenuEntry::has_callout_function() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MenuEntry::set_has_callout_function() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MenuEntry::clear_has_callout_function() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MenuEntry::clear_callout_function() {
  if (callout_function_ != &::google::protobuf::internal::kEmptyString) {
    callout_function_->clear();
  }
  clear_has_callout_function();
}
inline const ::std::string& MenuEntry::callout_function() const {
  return *callout_function_;
}
inline void MenuEntry::set_callout_function(const ::std::string& value) {
  set_has_callout_function();
  if (callout_function_ == &::google::protobuf::internal::kEmptyString) {
    callout_function_ = new ::std::string;
  }
  callout_function_->assign(value);
}
inline void MenuEntry::set_callout_function(const char* value) {
  set_has_callout_function();
  if (callout_function_ == &::google::protobuf::internal::kEmptyString) {
    callout_function_ = new ::std::string;
  }
  callout_function_->assign(value);
}
inline void MenuEntry::set_callout_function(const char* value, size_t size) {
  set_has_callout_function();
  if (callout_function_ == &::google::protobuf::internal::kEmptyString) {
    callout_function_ = new ::std::string;
  }
  callout_function_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MenuEntry::mutable_callout_function() {
  set_has_callout_function();
  if (callout_function_ == &::google::protobuf::internal::kEmptyString) {
    callout_function_ = new ::std::string;
  }
  return callout_function_;
}
inline ::std::string* MenuEntry::release_callout_function() {
  clear_has_callout_function();
  if (callout_function_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = callout_function_;
    callout_function_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MenuEntry::set_allocated_callout_function(::std::string* callout_function) {
  if (callout_function_ != &::google::protobuf::internal::kEmptyString) {
    delete callout_function_;
  }
  if (callout_function) {
    set_has_callout_function();
    callout_function_ = callout_function;
  } else {
    clear_has_callout_function();
    callout_function_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Menu

// optional .rec.command.Description description = 1;
inline bool Menu::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Menu::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Menu::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Menu::clear_description() {
  if (description_ != NULL) description_->::rec::command::Description::Clear();
  clear_has_description();
}
inline const ::rec::command::Description& Menu::description() const {
  return description_ != NULL ? *description_ : *default_instance_->description_;
}
inline ::rec::command::Description* Menu::mutable_description() {
  set_has_description();
  if (description_ == NULL) description_ = new ::rec::command::Description;
  return description_;
}
inline ::rec::command::Description* Menu::release_description() {
  clear_has_description();
  ::rec::command::Description* temp = description_;
  description_ = NULL;
  return temp;
}
inline void Menu::set_allocated_description(::rec::command::Description* description) {
  delete description_;
  description_ = description;
  if (description) {
    set_has_description();
  } else {
    clear_has_description();
  }
}

// optional string extends = 2;
inline bool Menu::has_extends() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Menu::set_has_extends() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Menu::clear_has_extends() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Menu::clear_extends() {
  if (extends_ != &::google::protobuf::internal::kEmptyString) {
    extends_->clear();
  }
  clear_has_extends();
}
inline const ::std::string& Menu::extends() const {
  return *extends_;
}
inline void Menu::set_extends(const ::std::string& value) {
  set_has_extends();
  if (extends_ == &::google::protobuf::internal::kEmptyString) {
    extends_ = new ::std::string;
  }
  extends_->assign(value);
}
inline void Menu::set_extends(const char* value) {
  set_has_extends();
  if (extends_ == &::google::protobuf::internal::kEmptyString) {
    extends_ = new ::std::string;
  }
  extends_->assign(value);
}
inline void Menu::set_extends(const char* value, size_t size) {
  set_has_extends();
  if (extends_ == &::google::protobuf::internal::kEmptyString) {
    extends_ = new ::std::string;
  }
  extends_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Menu::mutable_extends() {
  set_has_extends();
  if (extends_ == &::google::protobuf::internal::kEmptyString) {
    extends_ = new ::std::string;
  }
  return extends_;
}
inline ::std::string* Menu::release_extends() {
  clear_has_extends();
  if (extends_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extends_;
    extends_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Menu::set_allocated_extends(::std::string* extends) {
  if (extends_ != &::google::protobuf::internal::kEmptyString) {
    delete extends_;
  }
  if (extends) {
    set_has_extends();
    extends_ = extends;
  } else {
    clear_has_extends();
    extends_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .rec.slow.MenuEntry entry = 3;
inline int Menu::entry_size() const {
  return entry_.size();
}
inline void Menu::clear_entry() {
  entry_.Clear();
}
inline const ::rec::slow::MenuEntry& Menu::entry(int index) const {
  return entry_.Get(index);
}
inline ::rec::slow::MenuEntry* Menu::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::rec::slow::MenuEntry* Menu::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::MenuEntry >&
Menu::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::rec::slow::MenuEntry >*
Menu::mutable_entry() {
  return &entry_;
}

// -------------------------------------------------------------------

// Menus

// repeated .rec.slow.Menu menu = 1;
inline int Menus::menu_size() const {
  return menu_.size();
}
inline void Menus::clear_menu() {
  menu_.Clear();
}
inline const ::rec::slow::Menu& Menus::menu(int index) const {
  return menu_.Get(index);
}
inline ::rec::slow::Menu* Menus::mutable_menu(int index) {
  return menu_.Mutable(index);
}
inline ::rec::slow::Menu* Menus::add_menu() {
  return menu_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rec::slow::Menu >&
Menus::menu() const {
  return menu_;
}
inline ::google::protobuf::RepeatedPtrField< ::rec::slow::Menu >*
Menus::mutable_menu() {
  return &menu_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace slow
}  // namespace rec

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rec::slow::Command_Id>() {
  return ::rec::slow::Command_Id_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rec_2fslow_2fcommands_2fCommand_2eproto__INCLUDED
