// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rec/slow/LegacyDatabase.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "rec/slow/LegacyDatabase.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace rec {
namespace slow {

namespace {

const ::google::protobuf::Descriptor* LegacyLoopPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LegacyLoopPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* Track_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Track_reflection_ = NULL;
const ::google::protobuf::Descriptor* CD_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CD_reflection_ = NULL;
const ::google::protobuf::Descriptor* LegacyDatabase_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LegacyDatabase_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_rec_2fslow_2fLegacyDatabase_2eproto() {
  protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "rec/slow/LegacyDatabase.proto");
  GOOGLE_CHECK(file != NULL);
  LegacyLoopPoint_descriptor_ = file->message_type(0);
  static const int LegacyLoopPoint_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, start_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, end_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, comment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, chords_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, lyrics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, notation_),
  };
  LegacyLoopPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LegacyLoopPoint_descriptor_,
      LegacyLoopPoint::default_instance_,
      LegacyLoopPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyLoopPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LegacyLoopPoint));
  Track_descriptor_ = file->message_type(1);
  static const int Track_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, artist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, comments_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, notation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, last_pitch_change_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, loop_point_),
  };
  Track_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Track_descriptor_,
      Track::default_instance_,
      Track_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Track, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Track));
  CD_descriptor_ = file->message_type(2);
  static const int CD_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, cd_length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, track_length_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, num_tracks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, title_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, artist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, track_),
  };
  CD_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CD_descriptor_,
      CD::default_instance_,
      CD_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CD, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CD));
  LegacyDatabase_descriptor_ = file->message_type(3);
  static const int LegacyDatabase_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyDatabase, cd_),
  };
  LegacyDatabase_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LegacyDatabase_descriptor_,
      LegacyDatabase::default_instance_,
      LegacyDatabase_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyDatabase, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LegacyDatabase, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LegacyDatabase));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_rec_2fslow_2fLegacyDatabase_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LegacyLoopPoint_descriptor_, &LegacyLoopPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Track_descriptor_, &Track::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CD_descriptor_, &CD::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LegacyDatabase_descriptor_, &LegacyDatabase::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_rec_2fslow_2fLegacyDatabase_2eproto() {
  delete LegacyLoopPoint::default_instance_;
  delete LegacyLoopPoint_reflection_;
  delete Track::default_instance_;
  delete Track_reflection_;
  delete CD::default_instance_;
  delete CD_reflection_;
  delete LegacyDatabase::default_instance_;
  delete LegacyDatabase_reflection_;
}

void protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\035rec/slow/LegacyDatabase.proto\022\010rec.slo"
    "w\"z\n\017LegacyLoopPoint\022\022\n\nstart_time\030\001 \001(\004"
    "\022\020\n\010end_time\030\002 \001(\004\022\017\n\007comment\030\003 \001(\t\022\016\n\006c"
    "hords\030\004 \001(\t\022\016\n\006lyrics\030\005 \001(\t\022\020\n\010notation\030"
    "\006 \001(\t\"\243\001\n\005Track\022\016\n\006number\030\001 \001(\r\022\014\n\004name\030"
    "\002 \001(\t\022\016\n\006artist\030\003 \001(\t\022\020\n\010comments\030\004 \001(\t\022"
    "\020\n\010notation\030\005 \001(\t\022\031\n\021last_pitch_change\030\006"
    " \001(\r\022-\n\nloop_point\030\007 \003(\0132\031.rec.slow.Lega"
    "cyLoopPoint\"\200\001\n\002CD\022\021\n\tcd_length\030\001 \001(\004\022\024\n"
    "\014track_length\030\002 \001(\004\022\022\n\nnum_tracks\030\003 \001(\004\022"
    "\r\n\005title\030\004 \001(\t\022\016\n\006artist\030\005 \001(\t\022\036\n\005track\030"
    "\006 \003(\0132\017.rec.slow.Track\"*\n\016LegacyDatabase"
    "\022\030\n\002cd\030\001 \003(\0132\014.rec.slow.CD", 506);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "rec/slow/LegacyDatabase.proto", &protobuf_RegisterTypes);
  LegacyLoopPoint::default_instance_ = new LegacyLoopPoint();
  Track::default_instance_ = new Track();
  CD::default_instance_ = new CD();
  LegacyDatabase::default_instance_ = new LegacyDatabase();
  LegacyLoopPoint::default_instance_->InitAsDefaultInstance();
  Track::default_instance_->InitAsDefaultInstance();
  CD::default_instance_->InitAsDefaultInstance();
  LegacyDatabase::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_rec_2fslow_2fLegacyDatabase_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_rec_2fslow_2fLegacyDatabase_2eproto {
  StaticDescriptorInitializer_rec_2fslow_2fLegacyDatabase_2eproto() {
    protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto();
  }
} static_descriptor_initializer_rec_2fslow_2fLegacyDatabase_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int LegacyLoopPoint::kStartTimeFieldNumber;
const int LegacyLoopPoint::kEndTimeFieldNumber;
const int LegacyLoopPoint::kCommentFieldNumber;
const int LegacyLoopPoint::kChordsFieldNumber;
const int LegacyLoopPoint::kLyricsFieldNumber;
const int LegacyLoopPoint::kNotationFieldNumber;
#endif  // !_MSC_VER

LegacyLoopPoint::LegacyLoopPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LegacyLoopPoint::InitAsDefaultInstance() {
}

LegacyLoopPoint::LegacyLoopPoint(const LegacyLoopPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LegacyLoopPoint::SharedCtor() {
  _cached_size_ = 0;
  start_time_ = GOOGLE_ULONGLONG(0);
  end_time_ = GOOGLE_ULONGLONG(0);
  comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  chords_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lyrics_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  notation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LegacyLoopPoint::~LegacyLoopPoint() {
  SharedDtor();
}

void LegacyLoopPoint::SharedDtor() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (chords_ != &::google::protobuf::internal::kEmptyString) {
    delete chords_;
  }
  if (lyrics_ != &::google::protobuf::internal::kEmptyString) {
    delete lyrics_;
  }
  if (notation_ != &::google::protobuf::internal::kEmptyString) {
    delete notation_;
  }
  if (this != default_instance_) {
  }
}

void LegacyLoopPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LegacyLoopPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LegacyLoopPoint_descriptor_;
}

const LegacyLoopPoint& LegacyLoopPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto();
  return *default_instance_;
}

LegacyLoopPoint* LegacyLoopPoint::default_instance_ = NULL;

LegacyLoopPoint* LegacyLoopPoint::New() const {
  return new LegacyLoopPoint;
}

void LegacyLoopPoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_time_ = GOOGLE_ULONGLONG(0);
    end_time_ = GOOGLE_ULONGLONG(0);
    if (has_comment()) {
      if (comment_ != &::google::protobuf::internal::kEmptyString) {
        comment_->clear();
      }
    }
    if (has_chords()) {
      if (chords_ != &::google::protobuf::internal::kEmptyString) {
        chords_->clear();
      }
    }
    if (has_lyrics()) {
      if (lyrics_ != &::google::protobuf::internal::kEmptyString) {
        lyrics_->clear();
      }
    }
    if (has_notation()) {
      if (notation_ != &::google::protobuf::internal::kEmptyString) {
        notation_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LegacyLoopPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 start_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_time_)));
          set_has_start_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_end_time;
        break;
      }

      // optional uint64 end_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_comment;
        break;
      }

      // optional string comment = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->comment().data(), this->comment().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_chords;
        break;
      }

      // optional string chords = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chords:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_chords()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->chords().data(), this->chords().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_lyrics;
        break;
      }

      // optional string lyrics = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lyrics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lyrics()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->lyrics().data(), this->lyrics().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_notation;
        break;
      }

      // optional string notation = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_notation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->notation().data(), this->notation().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LegacyLoopPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 start_time = 1;
  if (has_start_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->start_time(), output);
  }

  // optional uint64 end_time = 2;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->end_time(), output);
  }

  // optional string comment = 3;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comment().data(), this->comment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->comment(), output);
  }

  // optional string chords = 4;
  if (has_chords()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->chords().data(), this->chords().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->chords(), output);
  }

  // optional string lyrics = 5;
  if (has_lyrics()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lyrics().data(), this->lyrics().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->lyrics(), output);
  }

  // optional string notation = 6;
  if (has_notation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notation().data(), this->notation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->notation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LegacyLoopPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 start_time = 1;
  if (has_start_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->start_time(), target);
  }

  // optional uint64 end_time = 2;
  if (has_end_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->end_time(), target);
  }

  // optional string comment = 3;
  if (has_comment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comment().data(), this->comment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->comment(), target);
  }

  // optional string chords = 4;
  if (has_chords()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->chords().data(), this->chords().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->chords(), target);
  }

  // optional string lyrics = 5;
  if (has_lyrics()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->lyrics().data(), this->lyrics().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->lyrics(), target);
  }

  // optional string notation = 6;
  if (has_notation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notation().data(), this->notation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->notation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LegacyLoopPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 start_time = 1;
    if (has_start_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_time());
    }

    // optional uint64 end_time = 2;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->end_time());
    }

    // optional string comment = 3;
    if (has_comment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comment());
    }

    // optional string chords = 4;
    if (has_chords()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->chords());
    }

    // optional string lyrics = 5;
    if (has_lyrics()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->lyrics());
    }

    // optional string notation = 6;
    if (has_notation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->notation());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LegacyLoopPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LegacyLoopPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LegacyLoopPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LegacyLoopPoint::MergeFrom(const LegacyLoopPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_time()) {
      set_start_time(from.start_time());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_comment()) {
      set_comment(from.comment());
    }
    if (from.has_chords()) {
      set_chords(from.chords());
    }
    if (from.has_lyrics()) {
      set_lyrics(from.lyrics());
    }
    if (from.has_notation()) {
      set_notation(from.notation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LegacyLoopPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LegacyLoopPoint::CopyFrom(const LegacyLoopPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LegacyLoopPoint::IsInitialized() const {

  return true;
}

void LegacyLoopPoint::Swap(LegacyLoopPoint* other) {
  if (other != this) {
    std::swap(start_time_, other->start_time_);
    std::swap(end_time_, other->end_time_);
    std::swap(comment_, other->comment_);
    std::swap(chords_, other->chords_);
    std::swap(lyrics_, other->lyrics_);
    std::swap(notation_, other->notation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LegacyLoopPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LegacyLoopPoint_descriptor_;
  metadata.reflection = LegacyLoopPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Track::kNumberFieldNumber;
const int Track::kNameFieldNumber;
const int Track::kArtistFieldNumber;
const int Track::kCommentsFieldNumber;
const int Track::kNotationFieldNumber;
const int Track::kLastPitchChangeFieldNumber;
const int Track::kLoopPointFieldNumber;
#endif  // !_MSC_VER

Track::Track()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Track::InitAsDefaultInstance() {
}

Track::Track(const Track& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Track::SharedCtor() {
  _cached_size_ = 0;
  number_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  artist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  notation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  last_pitch_change_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Track::~Track() {
  SharedDtor();
}

void Track::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (artist_ != &::google::protobuf::internal::kEmptyString) {
    delete artist_;
  }
  if (comments_ != &::google::protobuf::internal::kEmptyString) {
    delete comments_;
  }
  if (notation_ != &::google::protobuf::internal::kEmptyString) {
    delete notation_;
  }
  if (this != default_instance_) {
  }
}

void Track::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Track::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Track_descriptor_;
}

const Track& Track::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto();
  return *default_instance_;
}

Track* Track::default_instance_ = NULL;

Track* Track::New() const {
  return new Track;
}

void Track::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    number_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_artist()) {
      if (artist_ != &::google::protobuf::internal::kEmptyString) {
        artist_->clear();
      }
    }
    if (has_comments()) {
      if (comments_ != &::google::protobuf::internal::kEmptyString) {
        comments_->clear();
      }
    }
    if (has_notation()) {
      if (notation_ != &::google::protobuf::internal::kEmptyString) {
        notation_->clear();
      }
    }
    last_pitch_change_ = 0u;
  }
  loop_point_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Track::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 number = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_artist;
        break;
      }

      // optional string artist = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_artist()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist().data(), this->artist().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_comments;
        break;
      }

      // optional string comments = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_comments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_comments()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->comments().data(), this->comments().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_notation;
        break;
      }

      // optional string notation = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_notation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_notation()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->notation().data(), this->notation().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_last_pitch_change;
        break;
      }

      // optional uint32 last_pitch_change = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_pitch_change:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &last_pitch_change_)));
          set_has_last_pitch_change();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_loop_point;
        break;
      }

      // repeated .rec.slow.LegacyLoopPoint loop_point = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loop_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loop_point()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_loop_point;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Track::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->number(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional string artist = 3;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->artist(), output);
  }

  // optional string comments = 4;
  if (has_comments()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comments().data(), this->comments().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->comments(), output);
  }

  // optional string notation = 5;
  if (has_notation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notation().data(), this->notation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->notation(), output);
  }

  // optional uint32 last_pitch_change = 6;
  if (has_last_pitch_change()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->last_pitch_change(), output);
  }

  // repeated .rec.slow.LegacyLoopPoint loop_point = 7;
  for (int i = 0; i < this->loop_point_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->loop_point(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Track::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 number = 1;
  if (has_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->number(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional string artist = 3;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->artist(), target);
  }

  // optional string comments = 4;
  if (has_comments()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->comments().data(), this->comments().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->comments(), target);
  }

  // optional string notation = 5;
  if (has_notation()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->notation().data(), this->notation().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->notation(), target);
  }

  // optional uint32 last_pitch_change = 6;
  if (has_last_pitch_change()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->last_pitch_change(), target);
  }

  // repeated .rec.slow.LegacyLoopPoint loop_point = 7;
  for (int i = 0; i < this->loop_point_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->loop_point(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Track::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 number = 1;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string artist = 3;
    if (has_artist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->artist());
    }

    // optional string comments = 4;
    if (has_comments()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->comments());
    }

    // optional string notation = 5;
    if (has_notation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->notation());
    }

    // optional uint32 last_pitch_change = 6;
    if (has_last_pitch_change()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->last_pitch_change());
    }

  }
  // repeated .rec.slow.LegacyLoopPoint loop_point = 7;
  total_size += 1 * this->loop_point_size();
  for (int i = 0; i < this->loop_point_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loop_point(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Track::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Track* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Track*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Track::MergeFrom(const Track& from) {
  GOOGLE_CHECK_NE(&from, this);
  loop_point_.MergeFrom(from.loop_point_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_artist()) {
      set_artist(from.artist());
    }
    if (from.has_comments()) {
      set_comments(from.comments());
    }
    if (from.has_notation()) {
      set_notation(from.notation());
    }
    if (from.has_last_pitch_change()) {
      set_last_pitch_change(from.last_pitch_change());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Track::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Track::CopyFrom(const Track& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Track::IsInitialized() const {

  return true;
}

void Track::Swap(Track* other) {
  if (other != this) {
    std::swap(number_, other->number_);
    std::swap(name_, other->name_);
    std::swap(artist_, other->artist_);
    std::swap(comments_, other->comments_);
    std::swap(notation_, other->notation_);
    std::swap(last_pitch_change_, other->last_pitch_change_);
    loop_point_.Swap(&other->loop_point_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Track::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Track_descriptor_;
  metadata.reflection = Track_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CD::kCdLengthFieldNumber;
const int CD::kTrackLengthFieldNumber;
const int CD::kNumTracksFieldNumber;
const int CD::kTitleFieldNumber;
const int CD::kArtistFieldNumber;
const int CD::kTrackFieldNumber;
#endif  // !_MSC_VER

CD::CD()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CD::InitAsDefaultInstance() {
}

CD::CD(const CD& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CD::SharedCtor() {
  _cached_size_ = 0;
  cd_length_ = GOOGLE_ULONGLONG(0);
  track_length_ = GOOGLE_ULONGLONG(0);
  num_tracks_ = GOOGLE_ULONGLONG(0);
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  artist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CD::~CD() {
  SharedDtor();
}

void CD::SharedDtor() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (artist_ != &::google::protobuf::internal::kEmptyString) {
    delete artist_;
  }
  if (this != default_instance_) {
  }
}

void CD::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CD::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CD_descriptor_;
}

const CD& CD::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto();
  return *default_instance_;
}

CD* CD::default_instance_ = NULL;

CD* CD::New() const {
  return new CD;
}

void CD::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cd_length_ = GOOGLE_ULONGLONG(0);
    track_length_ = GOOGLE_ULONGLONG(0);
    num_tracks_ = GOOGLE_ULONGLONG(0);
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::kEmptyString) {
        title_->clear();
      }
    }
    if (has_artist()) {
      if (artist_ != &::google::protobuf::internal::kEmptyString) {
        artist_->clear();
      }
    }
  }
  track_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CD::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 cd_length = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cd_length_)));
          set_has_cd_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_track_length;
        break;
      }

      // optional uint64 track_length = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_track_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &track_length_)));
          set_has_track_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num_tracks;
        break;
      }

      // optional uint64 num_tracks = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_tracks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &num_tracks_)));
          set_has_num_tracks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_title;
        break;
      }

      // optional string title = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->title().data(), this->title().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_artist;
        break;
      }

      // optional string artist = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_artist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_artist()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->artist().data(), this->artist().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_track;
        break;
      }

      // repeated .rec.slow.Track track = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_track:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_track()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_track;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CD::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 cd_length = 1;
  if (has_cd_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->cd_length(), output);
  }

  // optional uint64 track_length = 2;
  if (has_track_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->track_length(), output);
  }

  // optional uint64 num_tracks = 3;
  if (has_num_tracks()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->num_tracks(), output);
  }

  // optional string title = 4;
  if (has_title()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->title(), output);
  }

  // optional string artist = 5;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->artist(), output);
  }

  // repeated .rec.slow.Track track = 6;
  for (int i = 0; i < this->track_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->track(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CD::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint64 cd_length = 1;
  if (has_cd_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->cd_length(), target);
  }

  // optional uint64 track_length = 2;
  if (has_track_length()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->track_length(), target);
  }

  // optional uint64 num_tracks = 3;
  if (has_num_tracks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->num_tracks(), target);
  }

  // optional string title = 4;
  if (has_title()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->title(), target);
  }

  // optional string artist = 5;
  if (has_artist()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->artist().data(), this->artist().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->artist(), target);
  }

  // repeated .rec.slow.Track track = 6;
  for (int i = 0; i < this->track_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->track(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CD::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 cd_length = 1;
    if (has_cd_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cd_length());
    }

    // optional uint64 track_length = 2;
    if (has_track_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->track_length());
    }

    // optional uint64 num_tracks = 3;
    if (has_num_tracks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->num_tracks());
    }

    // optional string title = 4;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

    // optional string artist = 5;
    if (has_artist()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->artist());
    }

  }
  // repeated .rec.slow.Track track = 6;
  total_size += 1 * this->track_size();
  for (int i = 0; i < this->track_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->track(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CD::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CD* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CD*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CD::MergeFrom(const CD& from) {
  GOOGLE_CHECK_NE(&from, this);
  track_.MergeFrom(from.track_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cd_length()) {
      set_cd_length(from.cd_length());
    }
    if (from.has_track_length()) {
      set_track_length(from.track_length());
    }
    if (from.has_num_tracks()) {
      set_num_tracks(from.num_tracks());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_artist()) {
      set_artist(from.artist());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CD::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CD::CopyFrom(const CD& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CD::IsInitialized() const {

  return true;
}

void CD::Swap(CD* other) {
  if (other != this) {
    std::swap(cd_length_, other->cd_length_);
    std::swap(track_length_, other->track_length_);
    std::swap(num_tracks_, other->num_tracks_);
    std::swap(title_, other->title_);
    std::swap(artist_, other->artist_);
    track_.Swap(&other->track_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CD::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CD_descriptor_;
  metadata.reflection = CD_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LegacyDatabase::kCdFieldNumber;
#endif  // !_MSC_VER

LegacyDatabase::LegacyDatabase()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LegacyDatabase::InitAsDefaultInstance() {
}

LegacyDatabase::LegacyDatabase(const LegacyDatabase& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LegacyDatabase::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LegacyDatabase::~LegacyDatabase() {
  SharedDtor();
}

void LegacyDatabase::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LegacyDatabase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LegacyDatabase::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LegacyDatabase_descriptor_;
}

const LegacyDatabase& LegacyDatabase::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_rec_2fslow_2fLegacyDatabase_2eproto();
  return *default_instance_;
}

LegacyDatabase* LegacyDatabase::default_instance_ = NULL;

LegacyDatabase* LegacyDatabase::New() const {
  return new LegacyDatabase;
}

void LegacyDatabase::Clear() {
  cd_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LegacyDatabase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .rec.slow.CD cd = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_cd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_cd;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LegacyDatabase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .rec.slow.CD cd = 1;
  for (int i = 0; i < this->cd_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cd(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LegacyDatabase::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .rec.slow.CD cd = 1;
  for (int i = 0; i < this->cd_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cd(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LegacyDatabase::ByteSize() const {
  int total_size = 0;

  // repeated .rec.slow.CD cd = 1;
  total_size += 1 * this->cd_size();
  for (int i = 0; i < this->cd_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->cd(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LegacyDatabase::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LegacyDatabase* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LegacyDatabase*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LegacyDatabase::MergeFrom(const LegacyDatabase& from) {
  GOOGLE_CHECK_NE(&from, this);
  cd_.MergeFrom(from.cd_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LegacyDatabase::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LegacyDatabase::CopyFrom(const LegacyDatabase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LegacyDatabase::IsInitialized() const {

  return true;
}

void LegacyDatabase::Swap(LegacyDatabase* other) {
  if (other != this) {
    cd_.Swap(&other->cd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LegacyDatabase::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LegacyDatabase_descriptor_;
  metadata.reflection = LegacyDatabase_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace slow
}  // namespace rec

// @@protoc_insertion_point(global_scope)
