// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rec/command/Command.proto

#ifndef PROTOBUF_rec_2fcommand_2fCommand_2eproto__INCLUDED
#define PROTOBUF_rec_2fcommand_2fCommand_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "rec/data/proto/Address.pb.h"
// @@protoc_insertion_point(includes)

namespace rec {
namespace command {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rec_2fcommand_2fCommand_2eproto();
void protobuf_AssignDesc_rec_2fcommand_2fCommand_2eproto();
void protobuf_ShutdownFile_rec_2fcommand_2fCommand_2eproto();

class Description;
class Command;
class Commands;

enum Command_Id {
  Command_Id_NONE = 0,
  Command_Id_QUIT = 4097,
  Command_Id_DEL = 4098,
  Command_Id_CUT = 4099,
  Command_Id_COPY = 4100,
  Command_Id_PASTE = 4101,
  Command_Id_SELECT_ALL = 4102,
  Command_Id_DESELECT_ALL = 4103,
  Command_Id_JUCE_START = 4096,
  Command_Id_JUCE_END = 4104,
  Command_Id_BANK_SIZE = 10000
};
bool Command_Id_IsValid(int value);
const Command_Id Command_Id_Id_MIN = Command_Id_NONE;
const Command_Id Command_Id_Id_MAX = Command_Id_BANK_SIZE;
const int Command_Id_Id_ARRAYSIZE = Command_Id_Id_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Id_descriptor();
inline const ::std::string& Command_Id_Name(Command_Id value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Id_descriptor(), value);
}
inline bool Command_Id_Parse(
    const ::std::string& name, Command_Id* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Id>(
    Command_Id_descriptor(), name, value);
}
enum Command_Index {
  Command_Index_FIRST = 0,
  Command_Index_PREVIOUS = 1,
  Command_Index_CURRENT = 2,
  Command_Index_NEXT = 3,
  Command_Index_LAST = 4
};
bool Command_Index_IsValid(int value);
const Command_Index Command_Index_Index_MIN = Command_Index_FIRST;
const Command_Index Command_Index_Index_MAX = Command_Index_LAST;
const int Command_Index_Index_ARRAYSIZE = Command_Index_Index_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Index_descriptor();
inline const ::std::string& Command_Index_Name(Command_Index value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Index_descriptor(), value);
}
inline bool Command_Index_Parse(
    const ::std::string& name, Command_Index* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Index>(
    Command_Index_descriptor(), name, value);
}
enum Command_SetterType {
  Command_SetterType_TOGGLE = 0,
  Command_SetterType_SELECTION = 1
};
bool Command_SetterType_IsValid(int value);
const Command_SetterType Command_SetterType_SetterType_MIN = Command_SetterType_TOGGLE;
const Command_SetterType Command_SetterType_SetterType_MAX = Command_SetterType_SELECTION;
const int Command_SetterType_SetterType_ARRAYSIZE = Command_SetterType_SetterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_SetterType_descriptor();
inline const ::std::string& Command_SetterType_Name(Command_SetterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_SetterType_descriptor(), value);
}
inline bool Command_SetterType_Parse(
    const ::std::string& name, Command_SetterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_SetterType>(
    Command_SetterType_descriptor(), name, value);
}
// ===================================================================

class Description : public ::google::protobuf::Message {
 public:
  Description();
  virtual ~Description();

  Description(const Description& from);

  inline Description& operator=(const Description& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Description& default_instance();

  void Swap(Description* other);

  // implements Message ----------------------------------------------

  Description* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Description& from);
  void MergeFrom(const Description& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string menu = 2;
  inline int menu_size() const;
  inline void clear_menu();
  static const int kMenuFieldNumber = 2;
  inline const ::std::string& menu(int index) const;
  inline ::std::string* mutable_menu(int index);
  inline void set_menu(int index, const ::std::string& value);
  inline void set_menu(int index, const char* value);
  inline void set_menu(int index, const char* value, size_t size);
  inline ::std::string* add_menu();
  inline void add_menu(const ::std::string& value);
  inline void add_menu(const char* value);
  inline void add_menu(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& menu() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_menu();

  // repeated string full = 3;
  inline int full_size() const;
  inline void clear_full();
  static const int kFullFieldNumber = 3;
  inline const ::std::string& full(int index) const;
  inline ::std::string* mutable_full(int index);
  inline void set_full(int index, const ::std::string& value);
  inline void set_full(int index, const char* value);
  inline void set_full(int index, const char* value, size_t size);
  inline ::std::string* add_full();
  inline void add_full(const ::std::string& value);
  inline void add_full(const char* value);
  inline void add_full(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& full() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_full();

  // optional string help = 4;
  inline bool has_help() const;
  inline void clear_help();
  static const int kHelpFieldNumber = 4;
  inline const ::std::string& help() const;
  inline void set_help(const ::std::string& value);
  inline void set_help(const char* value);
  inline void set_help(const char* value, size_t size);
  inline ::std::string* mutable_help();
  inline ::std::string* release_help();
  inline void set_allocated_help(::std::string* help);

  // @@protoc_insertion_point(class_scope:rec.command.Description)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_help();
  inline void clear_has_help();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> menu_;
  ::google::protobuf::RepeatedPtrField< ::std::string> full_;
  ::std::string* help_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fcommand_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fcommand_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fcommand_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Description* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Id Id;
  static const Id NONE = Command_Id_NONE;
  static const Id QUIT = Command_Id_QUIT;
  static const Id DEL = Command_Id_DEL;
  static const Id CUT = Command_Id_CUT;
  static const Id COPY = Command_Id_COPY;
  static const Id PASTE = Command_Id_PASTE;
  static const Id SELECT_ALL = Command_Id_SELECT_ALL;
  static const Id DESELECT_ALL = Command_Id_DESELECT_ALL;
  static const Id JUCE_START = Command_Id_JUCE_START;
  static const Id JUCE_END = Command_Id_JUCE_END;
  static const Id BANK_SIZE = Command_Id_BANK_SIZE;
  static inline bool Id_IsValid(int value) {
    return Command_Id_IsValid(value);
  }
  static const Id Id_MIN =
    Command_Id_Id_MIN;
  static const Id Id_MAX =
    Command_Id_Id_MAX;
  static const int Id_ARRAYSIZE =
    Command_Id_Id_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Id_descriptor() {
    return Command_Id_descriptor();
  }
  static inline const ::std::string& Id_Name(Id value) {
    return Command_Id_Name(value);
  }
  static inline bool Id_Parse(const ::std::string& name,
      Id* value) {
    return Command_Id_Parse(name, value);
  }

  typedef Command_Index Index;
  static const Index FIRST = Command_Index_FIRST;
  static const Index PREVIOUS = Command_Index_PREVIOUS;
  static const Index CURRENT = Command_Index_CURRENT;
  static const Index NEXT = Command_Index_NEXT;
  static const Index LAST = Command_Index_LAST;
  static inline bool Index_IsValid(int value) {
    return Command_Index_IsValid(value);
  }
  static const Index Index_MIN =
    Command_Index_Index_MIN;
  static const Index Index_MAX =
    Command_Index_Index_MAX;
  static const int Index_ARRAYSIZE =
    Command_Index_Index_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Index_descriptor() {
    return Command_Index_descriptor();
  }
  static inline const ::std::string& Index_Name(Index value) {
    return Command_Index_Name(value);
  }
  static inline bool Index_Parse(const ::std::string& name,
      Index* value) {
    return Command_Index_Parse(name, value);
  }

  typedef Command_SetterType SetterType;
  static const SetterType TOGGLE = Command_SetterType_TOGGLE;
  static const SetterType SELECTION = Command_SetterType_SELECTION;
  static inline bool SetterType_IsValid(int value) {
    return Command_SetterType_IsValid(value);
  }
  static const SetterType SetterType_MIN =
    Command_SetterType_SetterType_MIN;
  static const SetterType SetterType_MAX =
    Command_SetterType_SetterType_MAX;
  static const int SetterType_ARRAYSIZE =
    Command_SetterType_SetterType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SetterType_descriptor() {
    return Command_SetterType_descriptor();
  }
  static inline const ::std::string& SetterType_Name(SetterType value) {
    return Command_SetterType_Name(value);
  }
  static inline bool SetterType_Parse(const ::std::string& name,
      SetterType* value) {
    return Command_SetterType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string id_string = 15;
  inline bool has_id_string() const;
  inline void clear_id_string();
  static const int kIdStringFieldNumber = 15;
  inline const ::std::string& id_string() const;
  inline void set_id_string(const ::std::string& value);
  inline void set_id_string(const char* value);
  inline void set_id_string(const char* value, size_t size);
  inline ::std::string* mutable_id_string();
  inline ::std::string* release_id_string();
  inline void set_allocated_id_string(::std::string* id_string);

  // optional sint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional string category = 3;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 3;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  inline void set_allocated_category(::std::string* category);

  // optional string submenu_name = 4;
  inline bool has_submenu_name() const;
  inline void clear_submenu_name();
  static const int kSubmenuNameFieldNumber = 4;
  inline const ::std::string& submenu_name() const;
  inline void set_submenu_name(const ::std::string& value);
  inline void set_submenu_name(const char* value);
  inline void set_submenu_name(const char* value, size_t size);
  inline ::std::string* mutable_submenu_name();
  inline ::std::string* release_submenu_name();
  inline void set_allocated_submenu_name(::std::string* submenu_name);

  // repeated uint32 submenu_separator = 14;
  inline int submenu_separator_size() const;
  inline void clear_submenu_separator();
  static const int kSubmenuSeparatorFieldNumber = 14;
  inline ::google::protobuf::uint32 submenu_separator(int index) const;
  inline void set_submenu_separator(int index, ::google::protobuf::uint32 value);
  inline void add_submenu_separator(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      submenu_separator() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_submenu_separator();

  // optional .rec.command.Description desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::rec::command::Description& desc() const;
  inline ::rec::command::Description* mutable_desc();
  inline ::rec::command::Description* release_desc();
  inline void set_allocated_desc(::rec::command::Description* desc);

  // repeated string keypress = 6;
  inline int keypress_size() const;
  inline void clear_keypress();
  static const int kKeypressFieldNumber = 6;
  inline const ::std::string& keypress(int index) const;
  inline ::std::string* mutable_keypress(int index);
  inline void set_keypress(int index, const ::std::string& value);
  inline void set_keypress(int index, const char* value);
  inline void set_keypress(int index, const char* value, size_t size);
  inline ::std::string* add_keypress();
  inline void add_keypress(const ::std::string& value);
  inline void add_keypress(const char* value);
  inline void add_keypress(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keypress() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keypress();

  // optional uint32 flags = 7;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 7;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional string setter = 8;
  inline bool has_setter() const;
  inline void clear_setter();
  static const int kSetterFieldNumber = 8;
  inline const ::std::string& setter() const;
  inline void set_setter(const ::std::string& value);
  inline void set_setter(const char* value);
  inline void set_setter(const char* value, size_t size);
  inline ::std::string* mutable_setter();
  inline ::std::string* release_setter();
  inline void set_allocated_setter(::std::string* setter);

  // optional .rec.command.Command.SetterType setter_type = 16;
  inline bool has_setter_type() const;
  inline void clear_setter_type();
  static const int kSetterTypeFieldNumber = 16;
  inline ::rec::command::Command_SetterType setter_type() const;
  inline void set_setter_type(::rec::command::Command_SetterType value);

  // optional uint32 size = 9;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional bool callout = 10;
  inline bool has_callout() const;
  inline void clear_callout();
  static const int kCalloutFieldNumber = 10;
  inline bool callout() const;
  inline void set_callout(bool value);

  // repeated string hidden = 11;
  inline int hidden_size() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 11;
  inline const ::std::string& hidden(int index) const;
  inline ::std::string* mutable_hidden(int index);
  inline void set_hidden(int index, const ::std::string& value);
  inline void set_hidden(int index, const char* value);
  inline void set_hidden(int index, const char* value, size_t size);
  inline ::std::string* add_hidden();
  inline void add_hidden(const ::std::string& value);
  inline void add_hidden(const char* value);
  inline void add_hidden(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hidden() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hidden();

  // repeated string disabled = 12;
  inline int disabled_size() const;
  inline void clear_disabled();
  static const int kDisabledFieldNumber = 12;
  inline const ::std::string& disabled(int index) const;
  inline ::std::string* mutable_disabled(int index);
  inline void set_disabled(int index, const ::std::string& value);
  inline void set_disabled(int index, const char* value);
  inline void set_disabled(int index, const char* value, size_t size);
  inline ::std::string* add_disabled();
  inline void add_disabled(const ::std::string& value);
  inline void add_disabled(const char* value);
  inline void add_disabled(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& disabled() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_disabled();

  // repeated string ticked = 13;
  inline int ticked_size() const;
  inline void clear_ticked();
  static const int kTickedFieldNumber = 13;
  inline const ::std::string& ticked(int index) const;
  inline ::std::string* mutable_ticked(int index);
  inline void set_ticked(int index, const ::std::string& value);
  inline void set_ticked(int index, const char* value);
  inline void set_ticked(int index, const char* value, size_t size);
  inline ::std::string* add_ticked();
  inline void add_ticked(const ::std::string& value);
  inline void add_ticked(const char* value);
  inline void add_ticked(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ticked() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ticked();

  // @@protoc_insertion_point(class_scope:rec.command.Command)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_id_string();
  inline void clear_has_id_string();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_submenu_name();
  inline void clear_has_submenu_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_setter();
  inline void clear_has_setter();
  inline void set_has_setter_type();
  inline void clear_has_setter_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_callout();
  inline void clear_has_callout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_string_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 index_;
  ::std::string* category_;
  ::std::string* submenu_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > submenu_separator_;
  ::rec::command::Description* desc_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keypress_;
  ::std::string* setter_;
  ::google::protobuf::uint32 flags_;
  int setter_type_;
  ::google::protobuf::uint32 size_;
  bool callout_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hidden_;
  ::google::protobuf::RepeatedPtrField< ::std::string> disabled_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ticked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fcommand_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fcommand_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fcommand_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Commands : public ::google::protobuf::Message {
 public:
  Commands();
  virtual ~Commands();

  Commands(const Commands& from);

  inline Commands& operator=(const Commands& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Commands& default_instance();

  void Swap(Commands* other);

  // implements Message ----------------------------------------------

  Commands* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Commands& from);
  void MergeFrom(const Commands& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .rec.command.Command command = 1;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 1;
  inline const ::rec::command::Command& command(int index) const;
  inline ::rec::command::Command* mutable_command(int index);
  inline ::rec::command::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::rec::command::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::rec::command::Command >*
      mutable_command();

  // @@protoc_insertion_point(class_scope:rec.command.Commands)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::rec::command::Command > command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rec_2fcommand_2fCommand_2eproto();
  friend void protobuf_AssignDesc_rec_2fcommand_2fCommand_2eproto();
  friend void protobuf_ShutdownFile_rec_2fcommand_2fCommand_2eproto();

  void InitAsDefaultInstance();
  static Commands* default_instance_;
};
// ===================================================================


// ===================================================================

// Description

// optional string name = 1;
inline bool Description::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Description::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Description::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Description::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Description::name() const {
  return *name_;
}
inline void Description::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Description::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Description::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Description::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Description::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Description::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string menu = 2;
inline int Description::menu_size() const {
  return menu_.size();
}
inline void Description::clear_menu() {
  menu_.Clear();
}
inline const ::std::string& Description::menu(int index) const {
  return menu_.Get(index);
}
inline ::std::string* Description::mutable_menu(int index) {
  return menu_.Mutable(index);
}
inline void Description::set_menu(int index, const ::std::string& value) {
  menu_.Mutable(index)->assign(value);
}
inline void Description::set_menu(int index, const char* value) {
  menu_.Mutable(index)->assign(value);
}
inline void Description::set_menu(int index, const char* value, size_t size) {
  menu_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Description::add_menu() {
  return menu_.Add();
}
inline void Description::add_menu(const ::std::string& value) {
  menu_.Add()->assign(value);
}
inline void Description::add_menu(const char* value) {
  menu_.Add()->assign(value);
}
inline void Description::add_menu(const char* value, size_t size) {
  menu_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Description::menu() const {
  return menu_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Description::mutable_menu() {
  return &menu_;
}

// repeated string full = 3;
inline int Description::full_size() const {
  return full_.size();
}
inline void Description::clear_full() {
  full_.Clear();
}
inline const ::std::string& Description::full(int index) const {
  return full_.Get(index);
}
inline ::std::string* Description::mutable_full(int index) {
  return full_.Mutable(index);
}
inline void Description::set_full(int index, const ::std::string& value) {
  full_.Mutable(index)->assign(value);
}
inline void Description::set_full(int index, const char* value) {
  full_.Mutable(index)->assign(value);
}
inline void Description::set_full(int index, const char* value, size_t size) {
  full_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Description::add_full() {
  return full_.Add();
}
inline void Description::add_full(const ::std::string& value) {
  full_.Add()->assign(value);
}
inline void Description::add_full(const char* value) {
  full_.Add()->assign(value);
}
inline void Description::add_full(const char* value, size_t size) {
  full_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Description::full() const {
  return full_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Description::mutable_full() {
  return &full_;
}

// optional string help = 4;
inline bool Description::has_help() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Description::set_has_help() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Description::clear_has_help() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Description::clear_help() {
  if (help_ != &::google::protobuf::internal::kEmptyString) {
    help_->clear();
  }
  clear_has_help();
}
inline const ::std::string& Description::help() const {
  return *help_;
}
inline void Description::set_help(const ::std::string& value) {
  set_has_help();
  if (help_ == &::google::protobuf::internal::kEmptyString) {
    help_ = new ::std::string;
  }
  help_->assign(value);
}
inline void Description::set_help(const char* value) {
  set_has_help();
  if (help_ == &::google::protobuf::internal::kEmptyString) {
    help_ = new ::std::string;
  }
  help_->assign(value);
}
inline void Description::set_help(const char* value, size_t size) {
  set_has_help();
  if (help_ == &::google::protobuf::internal::kEmptyString) {
    help_ = new ::std::string;
  }
  help_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Description::mutable_help() {
  set_has_help();
  if (help_ == &::google::protobuf::internal::kEmptyString) {
    help_ = new ::std::string;
  }
  return help_;
}
inline ::std::string* Description::release_help() {
  clear_has_help();
  if (help_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = help_;
    help_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Description::set_allocated_help(::std::string* help) {
  if (help_ != &::google::protobuf::internal::kEmptyString) {
    delete help_;
  }
  if (help) {
    set_has_help();
    help_ = help;
  } else {
    clear_has_help();
    help_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command

// optional uint32 id = 1;
inline bool Command::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Command::id() const {
  return id_;
}
inline void Command::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string id_string = 15;
inline bool Command::has_id_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_id_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_id_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_id_string() {
  if (id_string_ != &::google::protobuf::internal::kEmptyString) {
    id_string_->clear();
  }
  clear_has_id_string();
}
inline const ::std::string& Command::id_string() const {
  return *id_string_;
}
inline void Command::set_id_string(const ::std::string& value) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::kEmptyString) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(value);
}
inline void Command::set_id_string(const char* value) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::kEmptyString) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(value);
}
inline void Command::set_id_string(const char* value, size_t size) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::kEmptyString) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_id_string() {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::kEmptyString) {
    id_string_ = new ::std::string;
  }
  return id_string_;
}
inline ::std::string* Command::release_id_string() {
  clear_has_id_string();
  if (id_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_string_;
    id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_id_string(::std::string* id_string) {
  if (id_string_ != &::google::protobuf::internal::kEmptyString) {
    delete id_string_;
  }
  if (id_string) {
    set_has_id_string();
    id_string_ = id_string;
  } else {
    clear_has_id_string();
    id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 index = 2;
inline bool Command::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Command::index() const {
  return index_;
}
inline void Command::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional string category = 3;
inline bool Command::has_category() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_category() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_category() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& Command::category() const {
  return *category_;
}
inline void Command::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void Command::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void Command::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* Command::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_category(::std::string* category) {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    delete category_;
  }
  if (category) {
    set_has_category();
    category_ = category;
  } else {
    clear_has_category();
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string submenu_name = 4;
inline bool Command::has_submenu_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_submenu_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_submenu_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_submenu_name() {
  if (submenu_name_ != &::google::protobuf::internal::kEmptyString) {
    submenu_name_->clear();
  }
  clear_has_submenu_name();
}
inline const ::std::string& Command::submenu_name() const {
  return *submenu_name_;
}
inline void Command::set_submenu_name(const ::std::string& value) {
  set_has_submenu_name();
  if (submenu_name_ == &::google::protobuf::internal::kEmptyString) {
    submenu_name_ = new ::std::string;
  }
  submenu_name_->assign(value);
}
inline void Command::set_submenu_name(const char* value) {
  set_has_submenu_name();
  if (submenu_name_ == &::google::protobuf::internal::kEmptyString) {
    submenu_name_ = new ::std::string;
  }
  submenu_name_->assign(value);
}
inline void Command::set_submenu_name(const char* value, size_t size) {
  set_has_submenu_name();
  if (submenu_name_ == &::google::protobuf::internal::kEmptyString) {
    submenu_name_ = new ::std::string;
  }
  submenu_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_submenu_name() {
  set_has_submenu_name();
  if (submenu_name_ == &::google::protobuf::internal::kEmptyString) {
    submenu_name_ = new ::std::string;
  }
  return submenu_name_;
}
inline ::std::string* Command::release_submenu_name() {
  clear_has_submenu_name();
  if (submenu_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = submenu_name_;
    submenu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_submenu_name(::std::string* submenu_name) {
  if (submenu_name_ != &::google::protobuf::internal::kEmptyString) {
    delete submenu_name_;
  }
  if (submenu_name) {
    set_has_submenu_name();
    submenu_name_ = submenu_name;
  } else {
    clear_has_submenu_name();
    submenu_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 submenu_separator = 14;
inline int Command::submenu_separator_size() const {
  return submenu_separator_.size();
}
inline void Command::clear_submenu_separator() {
  submenu_separator_.Clear();
}
inline ::google::protobuf::uint32 Command::submenu_separator(int index) const {
  return submenu_separator_.Get(index);
}
inline void Command::set_submenu_separator(int index, ::google::protobuf::uint32 value) {
  submenu_separator_.Set(index, value);
}
inline void Command::add_submenu_separator(::google::protobuf::uint32 value) {
  submenu_separator_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Command::submenu_separator() const {
  return submenu_separator_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Command::mutable_submenu_separator() {
  return &submenu_separator_;
}

// optional .rec.command.Description desc = 5;
inline bool Command::has_desc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command::set_has_desc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command::clear_has_desc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command::clear_desc() {
  if (desc_ != NULL) desc_->::rec::command::Description::Clear();
  clear_has_desc();
}
inline const ::rec::command::Description& Command::desc() const {
  return desc_ != NULL ? *desc_ : *default_instance_->desc_;
}
inline ::rec::command::Description* Command::mutable_desc() {
  set_has_desc();
  if (desc_ == NULL) desc_ = new ::rec::command::Description;
  return desc_;
}
inline ::rec::command::Description* Command::release_desc() {
  clear_has_desc();
  ::rec::command::Description* temp = desc_;
  desc_ = NULL;
  return temp;
}
inline void Command::set_allocated_desc(::rec::command::Description* desc) {
  delete desc_;
  desc_ = desc;
  if (desc) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
}

// repeated string keypress = 6;
inline int Command::keypress_size() const {
  return keypress_.size();
}
inline void Command::clear_keypress() {
  keypress_.Clear();
}
inline const ::std::string& Command::keypress(int index) const {
  return keypress_.Get(index);
}
inline ::std::string* Command::mutable_keypress(int index) {
  return keypress_.Mutable(index);
}
inline void Command::set_keypress(int index, const ::std::string& value) {
  keypress_.Mutable(index)->assign(value);
}
inline void Command::set_keypress(int index, const char* value) {
  keypress_.Mutable(index)->assign(value);
}
inline void Command::set_keypress(int index, const char* value, size_t size) {
  keypress_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::add_keypress() {
  return keypress_.Add();
}
inline void Command::add_keypress(const ::std::string& value) {
  keypress_.Add()->assign(value);
}
inline void Command::add_keypress(const char* value) {
  keypress_.Add()->assign(value);
}
inline void Command::add_keypress(const char* value, size_t size) {
  keypress_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::keypress() const {
  return keypress_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_keypress() {
  return &keypress_;
}

// optional uint32 flags = 7;
inline bool Command::has_flags() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command::set_has_flags() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command::clear_has_flags() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 Command::flags() const {
  return flags_;
}
inline void Command::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional string setter = 8;
inline bool Command::has_setter() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command::set_has_setter() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command::clear_has_setter() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command::clear_setter() {
  if (setter_ != &::google::protobuf::internal::kEmptyString) {
    setter_->clear();
  }
  clear_has_setter();
}
inline const ::std::string& Command::setter() const {
  return *setter_;
}
inline void Command::set_setter(const ::std::string& value) {
  set_has_setter();
  if (setter_ == &::google::protobuf::internal::kEmptyString) {
    setter_ = new ::std::string;
  }
  setter_->assign(value);
}
inline void Command::set_setter(const char* value) {
  set_has_setter();
  if (setter_ == &::google::protobuf::internal::kEmptyString) {
    setter_ = new ::std::string;
  }
  setter_->assign(value);
}
inline void Command::set_setter(const char* value, size_t size) {
  set_has_setter();
  if (setter_ == &::google::protobuf::internal::kEmptyString) {
    setter_ = new ::std::string;
  }
  setter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_setter() {
  set_has_setter();
  if (setter_ == &::google::protobuf::internal::kEmptyString) {
    setter_ = new ::std::string;
  }
  return setter_;
}
inline ::std::string* Command::release_setter() {
  clear_has_setter();
  if (setter_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = setter_;
    setter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command::set_allocated_setter(::std::string* setter) {
  if (setter_ != &::google::protobuf::internal::kEmptyString) {
    delete setter_;
  }
  if (setter) {
    set_has_setter();
    setter_ = setter;
  } else {
    clear_has_setter();
    setter_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .rec.command.Command.SetterType setter_type = 16;
inline bool Command::has_setter_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Command::set_has_setter_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Command::clear_has_setter_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Command::clear_setter_type() {
  setter_type_ = 0;
  clear_has_setter_type();
}
inline ::rec::command::Command_SetterType Command::setter_type() const {
  return static_cast< ::rec::command::Command_SetterType >(setter_type_);
}
inline void Command::set_setter_type(::rec::command::Command_SetterType value) {
  assert(::rec::command::Command_SetterType_IsValid(value));
  set_has_setter_type();
  setter_type_ = value;
}

// optional uint32 size = 9;
inline bool Command::has_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Command::set_has_size() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Command::clear_has_size() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Command::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 Command::size() const {
  return size_;
}
inline void Command::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// optional bool callout = 10;
inline bool Command::has_callout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Command::set_has_callout() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Command::clear_has_callout() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Command::clear_callout() {
  callout_ = false;
  clear_has_callout();
}
inline bool Command::callout() const {
  return callout_;
}
inline void Command::set_callout(bool value) {
  set_has_callout();
  callout_ = value;
}

// repeated string hidden = 11;
inline int Command::hidden_size() const {
  return hidden_.size();
}
inline void Command::clear_hidden() {
  hidden_.Clear();
}
inline const ::std::string& Command::hidden(int index) const {
  return hidden_.Get(index);
}
inline ::std::string* Command::mutable_hidden(int index) {
  return hidden_.Mutable(index);
}
inline void Command::set_hidden(int index, const ::std::string& value) {
  hidden_.Mutable(index)->assign(value);
}
inline void Command::set_hidden(int index, const char* value) {
  hidden_.Mutable(index)->assign(value);
}
inline void Command::set_hidden(int index, const char* value, size_t size) {
  hidden_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::add_hidden() {
  return hidden_.Add();
}
inline void Command::add_hidden(const ::std::string& value) {
  hidden_.Add()->assign(value);
}
inline void Command::add_hidden(const char* value) {
  hidden_.Add()->assign(value);
}
inline void Command::add_hidden(const char* value, size_t size) {
  hidden_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::hidden() const {
  return hidden_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_hidden() {
  return &hidden_;
}

// repeated string disabled = 12;
inline int Command::disabled_size() const {
  return disabled_.size();
}
inline void Command::clear_disabled() {
  disabled_.Clear();
}
inline const ::std::string& Command::disabled(int index) const {
  return disabled_.Get(index);
}
inline ::std::string* Command::mutable_disabled(int index) {
  return disabled_.Mutable(index);
}
inline void Command::set_disabled(int index, const ::std::string& value) {
  disabled_.Mutable(index)->assign(value);
}
inline void Command::set_disabled(int index, const char* value) {
  disabled_.Mutable(index)->assign(value);
}
inline void Command::set_disabled(int index, const char* value, size_t size) {
  disabled_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::add_disabled() {
  return disabled_.Add();
}
inline void Command::add_disabled(const ::std::string& value) {
  disabled_.Add()->assign(value);
}
inline void Command::add_disabled(const char* value) {
  disabled_.Add()->assign(value);
}
inline void Command::add_disabled(const char* value, size_t size) {
  disabled_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::disabled() const {
  return disabled_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_disabled() {
  return &disabled_;
}

// repeated string ticked = 13;
inline int Command::ticked_size() const {
  return ticked_.size();
}
inline void Command::clear_ticked() {
  ticked_.Clear();
}
inline const ::std::string& Command::ticked(int index) const {
  return ticked_.Get(index);
}
inline ::std::string* Command::mutable_ticked(int index) {
  return ticked_.Mutable(index);
}
inline void Command::set_ticked(int index, const ::std::string& value) {
  ticked_.Mutable(index)->assign(value);
}
inline void Command::set_ticked(int index, const char* value) {
  ticked_.Mutable(index)->assign(value);
}
inline void Command::set_ticked(int index, const char* value, size_t size) {
  ticked_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::add_ticked() {
  return ticked_.Add();
}
inline void Command::add_ticked(const ::std::string& value) {
  ticked_.Add()->assign(value);
}
inline void Command::add_ticked(const char* value) {
  ticked_.Add()->assign(value);
}
inline void Command::add_ticked(const char* value, size_t size) {
  ticked_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command::ticked() const {
  return ticked_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command::mutable_ticked() {
  return &ticked_;
}

// -------------------------------------------------------------------

// Commands

// repeated .rec.command.Command command = 1;
inline int Commands::command_size() const {
  return command_.size();
}
inline void Commands::clear_command() {
  command_.Clear();
}
inline const ::rec::command::Command& Commands::command(int index) const {
  return command_.Get(index);
}
inline ::rec::command::Command* Commands::mutable_command(int index) {
  return command_.Mutable(index);
}
inline ::rec::command::Command* Commands::add_command() {
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rec::command::Command >&
Commands::command() const {
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::rec::command::Command >*
Commands::mutable_command() {
  return &command_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace command
}  // namespace rec

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rec::command::Command_Id>() {
  return ::rec::command::Command_Id_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rec::command::Command_Index>() {
  return ::rec::command::Command_Index_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rec::command::Command_SetterType>() {
  return ::rec::command::Command_SetterType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rec_2fcommand_2fCommand_2eproto__INCLUDED
